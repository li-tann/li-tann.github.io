"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6039],{7232:(t,e,r)=>{r.r(e),r.d(e,{assets:()=>_,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>m,toc:()=>d});var n=r(5893),a=r(1151);const i={custom_edit_url:null},s="\u5f3a\u5ea6\u5f71\u50cf\u7684\u62c9\u4f38",m={id:"document/image_processing/img_power_stretch",title:"\u5f3a\u5ea6\u5f71\u50cf\u7684\u62c9\u4f38",description:"\u7b49\u6bd4\u7f29\u653e",source:"@site/docs/document/image_processing/img_power_stretch.md",sourceDirName:"document/image_processing",slug:"/document/image_processing/img_power_stretch",permalink:"/docs/document/image_processing/img_power_stretch",draft:!1,unlisted:!1,editUrl:null,tags:[],version:"current",frontMatter:{custom_edit_url:null},sidebar:"docs",previous:{title:"\u6ee4\u6ce2",permalink:"/docs/document/image_processing/img_filter"},next:{title:"\u5f71\u50cf\u91cd\u91c7\u6837",permalink:"/docs/document/image_processing/img_resampling"}},_={},d=[{value:"\u767e\u5206\u6bd4\u62c9\u4f38",id:"\u767e\u5206\u6bd4\u62c9\u4f38",level:2},{value:"code",id:"code",level:3}];function u(t){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{id:"\u5f3a\u5ea6\u5f71\u50cf\u7684\u62c9\u4f38",children:"\u5f3a\u5ea6\u5f71\u50cf\u7684\u62c9\u4f38"}),"\n",(0,n.jsx)(e.p,{children:"\u7b49\u6bd4\u7f29\u653e"}),"\n",(0,n.jsx)(e.p,{children:"\u628afloat\u683c\u5f0f\u7684\u5f3a\u5ea6\u56fe\u8f6c\u6362\u4e3a8bit\u5f71\u50cf\u65f6\uff0c\u53d7\u5f3a\u5ea6\u56fe\u566a\u58f0\u5f71\u50cf\uff0c\u7b49\u6bd4\u7f29\u653e\u5f3a\u5ea6\u56fe\u6570\u503c\u65f6\uff0c\u5176\u4e2d\u7684\u6709\u6548\u4fe1\u606f\u4f1a\u88ab\u538b\u7f29\u5230\u975e\u5e38\u5c0f\u7684\u8303\u56f4\uff0c\u4ece\u800c\u5bfc\u81f4\u751f\u6210\u76848bit\u56fe\u89c6\u89c9\u6548\u679c\u65f6\u4e00\u7247\u6f06\u9ed1\u6216\u4e00\u7247\u7a7a\u767d\u3002"}),"\n",(0,n.jsxs)(e.p,{children:["\u4ee5",(0,n.jsx)(e.code,{children:"power.tif"}),"\u56fe\u4e3a\u4f8b"]}),"\n",(0,n.jsx)(e.h2,{id:"\u767e\u5206\u6bd4\u62c9\u4f38",children:"\u767e\u5206\u6bd4\u62c9\u4f38"}),"\n",(0,n.jsx)(e.h3,{id:"code",children:"code"}),"\n",(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:"language-cpp",children:'int gdt_float32_img_convert_to_gdt_byte(const char* src_imgpath, const char* dst_imgpath,size_t histgram_size, double stretch_rate)\r\n{\r\n    auto start = std::chrono::system_clock::now();\r\n    GDALAllRegister();\r\n    GDALDataset* p_src_dataset = static_cast<GDALDataset*>(GDALOpen(src_imgpath,GA_ReadOnly));\r\n    GDALRasterBand* raster_band = p_src_dataset->GetRasterBand(1);\r\n    int width = p_src_dataset->GetRasterXSize();\r\n    int height= p_src_dataset->GetRasterYSize();\r\n    GDALDataType src_datatype = raster_band->GetRasterDataType();\r\n\r\n    if(src_datatype != GDT_Float32){\r\n        std::cout<<"datatype != dgt_float32"<<std::endl;\r\n        return -1;\r\n    }\r\n    double maxmum,minmum;\r\n    GUIntBig* histgram_result = new GUIntBig[histgram_size];\r\n    float* data = new float[size_t(width)*size_t(height)];\r\n    CPLErr cpl_err = raster_band->RasterIO(GF_Read,0,0,width,height,data,width,height,GDT_Float32,0,0);\r\n    if(cpl_err > 1){\r\n        std::cout<<"rasterio.read failed"<<std::endl;\r\n        return -2;\r\n    }\r\n    /// \u7edf\u8ba1\u5f71\u50cf\u7684\u6700\u5927\u6700\u5c0f\u503c\r\n    size_t k = 0;\r\n    for(; k<size_t(width)*size_t(height); k++){\r\n        if(!isnan(data[0])){\r\n            maxmum = minmum = double(data[0]);\r\n            break;\r\n        }\r\n    }\r\n    if(k == size_t(width)*size_t(height)-1){\r\n        std::cout<<"all data is nan date"<<std::endl;\r\n        return -3;\r\n    }\r\n    for(; k<size_t(width)*size_t(height); k++)\r\n    {\r\n        if(maxmum < double( data[k]))\r\n            maxmum = double(data[k]);\r\n        if(minmum > double(data[k]))\r\n            minmum = double(data[k]);\r\n\r\n    }\r\n  \r\n    /// \u7edf\u8ba1\u76f4\u65b9\u56fe\r\n    raster_band->GetHistogram(minmum,maxmum,int(histgram_size),histgram_result,FALSE,FALSE,GDALDummyProgress,nullptr);\r\n  \r\n    /// \u5206\u6790\u5bf9\u5e94\u767e\u5206\u6bd4\u62c9\u4f38\u91cf\u7684\u62c9\u4f38\u503c\r\n  \r\n    /// \u7edf\u8ba1\u5206\u5e03\u76f4\u65b9\u56fe\u7684\u7d2f\u8ba1\u503c\r\n    GUIntBig* histgram_accumulate = new GUIntBig[histgram_size];\r\n    histgram_accumulate[0] = histgram_result[0];\r\n\r\n    for(size_t i=1; i<histgram_size; i++){\r\n        histgram_accumulate[i] = histgram_accumulate[i-1] + histgram_result[i];\r\n    }\r\n\r\n    /// \u6362\u7b97\u6210\u767e\u5206\u6bd4\r\n    /// \u8ba1\u7b97\u6ee1\u8db3\u62c9\u4f38\u6bd4\u4f8b\u9644\u8fd1\u7684\u6570\u503c\u4f5c\u4e3a\u65b0\u7684\u6700\u5927\u503c\u6700\u5c0f\u503c\r\n\r\n    double minmum_new=0, maxmum_new=0;\r\n    bool get_minmum_new{false}, get_maxmum_new{false};\r\n    double* histgram_accumulate_percent = new double[histgram_size];\r\n\r\n    for(size_t i=0; i<histgram_size; i++){\r\n        histgram_accumulate_percent[i] = 1. * histgram_accumulate[i] / histgram_accumulate[histgram_size-1] ;\r\n        if(i==0)continue;\r\n        /// \u8003\u8651\u5230\u7b2c\u4e00\u4e2a\u503c\u5c31\u5927\u4e8e stretch_rate \u7684\u60c5\u51b5\r\n        if((histgram_accumulate_percent[i-1] < stretch_rate || i == 1) && histgram_accumulate_percent[i] > stretch_rate){\r\n            minmum_new = minmum + (maxmum - minmum)/ histgram_size * (i-1);\r\n            get_minmum_new = true;\r\n        }\r\n        if(histgram_accumulate_percent[i-1] < 1 - stretch_rate && histgram_accumulate_percent[i] > 1 - stretch_rate){\r\n\r\n            maxmum_new = minmum + (maxmum - minmum)/ histgram_size * i;\r\n            get_maxmum_new = true;\r\n        }\r\n    }\r\n\r\n    if(!get_maxmum_new || !get_minmum_new){\r\n        std::cout<<"calculate new minmax failed"<<std::endl;\r\n        return -4;\r\n    }\r\n    if(abs(maxmum_new - minmum_new)<0.00001){\r\n        std::cout<<"mistake: maxmum_new is equal to minmum"<<std::endl;\r\n        return -5;\r\n    }\r\n    std::cout<<"get_stretched_minmax, spend time: "<<core_spend_time(start)<<std::endl;\r\n\r\n    unsigned char* dst_data = new unsigned char[size_t(width)*size_t(height)];\r\n    for(size_t i=0; i<size_t(width)*size_t(height); i++)\r\n    {\r\n        float float_value = data[i];\r\n        float_value = (float_value > float(maxmum_new) ? float(maxmum_new) : float_value);\r\n        float_value = (float_value < float(minmum_new) ? float(minmum_new) : float_value);\r\n        /// \u5982\u679c\u8003\u8651\u5230nan\u503c\uff0c\u53ef\u4ee5\u5c06\u6b63\u5e38\u503c\u533a\u95f4\u8bbe\u7f6e\u4e3a1~255, nan\u503c\u4e3a0\r\n        int byte_value = int(255. * (double(float_value) - minmum_new) / (maxmum_new - minmum_new));\r\n        dst_data[i] = static_cast<unsigned char>(byte_value);\r\n    }\r\n\r\n    GDALDriver* p_driver_bmp = GetGDALDriverManager()->GetDriverByName("BMP");\r\n    GDALDataset* p_dst_dataset = p_driver_bmp->Create(dst_imgpath,width,height,1,GDT_Byte,nullptr);\r\n\r\n    GDALRasterBand* p_dst_rasterband = p_dst_dataset->GetRasterBand(1);\r\n\r\n    cpl_err = p_dst_rasterband->RasterIO(GF_Write,0,0,width,height,dst_data,width,height,GDT_Byte,0,0);\r\n    if(cpl_err > 1){\r\n        std::cout<<"rasterio.write failed"<<std::endl;\r\n        return -6;\r\n    }\r\n\r\n    std::cout<<"converted : "<<core_spend_time(start)<<std::endl;\r\n  \r\n\r\n    delete [] data;\r\n    GDALClose(p_src_dataset);\r\n    delete [] dst_data;\r\n    GDALClose(p_dst_dataset);\r\n    \r\n    return 1;\r\n\r\n}\n'})})]})}function c(t={}){const{wrapper:e}={...(0,a.a)(),...t.components};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(u,{...t})}):u(t)}},1151:(t,e,r)=>{r.d(e,{Z:()=>m,a:()=>s});var n=r(7294);const a={},i=n.createContext(a);function s(t){const e=n.useContext(i);return n.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function m(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:s(t.components),n.createElement(i.Provider,{value:e},t.children)}}}]);